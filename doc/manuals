Links:
Player: https://github.com/MichaelMammoliti/jAudio.js

Лекция 2 марта 2016
Основы веб-разработки (первый семестр)
Примеры питонячих демонов


https://github.com/sat2707/web/blob/master/tcp_servers/simple.py
https://github.com/sat2707/web/blob/master/tcp_servers/simple_http.py
https://github.com/sat2707/web/blob/master/tcp_servers/fork.py
https://github.com/sat2707/web/blob/master/tcp_servers/prefork.py
https://github.com/sat2707/web/blob/master/tcp_servers/async.py


Примеры конфы nginx


https://github.com/sat2707/web/blob/master/tcp_servers/nginx.conf
https://github.com/sat2707/web/blob/master/tcp_servers/itportal.conf
https://github.com/sat2707/web/blob/master/tcp_servers/mipt.conf

UPD. Прошу прощения, конкретика по ДЗ и туториал по нему немного задерживаются, будут завтра.
Презентации к первой и второй лекции можно взять тут
https://s.mail.ru/2JoxRjj2SZbC/web%201.pdf
https://s.mail.ru/372BnaJVTX47/web2.pdf

UPD2. Домашнее задание.

Ваша задача, как я и говорил на лекции, поставить nginx, gunicorn и django + добиться того, чтобы все эти компоненты смогли работать вместе. Я предполагаю, что вы будет всё ставить себе на ноуты, на которых у вас установлен ubuntu.
В убунту системные пакеты (например, nginx) устанавливаются с помощью пакетного менеджера apt-get. О его устройстве нам особо ничего знать не нужно, мы им будем пользоваться только в разрезе "ой я хочу вот nginx, apt-get поставь мне его пожалуйста" :)
Попробую попутно объяснять, что мы делаем и зачем. Оставшиеся вопросы можете накидывать в комментарии. Начнем..

Ставим django

1) Прежде всего создаем папку под проект (я проект назову допустим stackoverflow, вы можете назвать как вам угодно)
Папка создается командой mkdir имя_папки

vagrant@precise64:~$ mkdir stackoverflow
vagrant@precise64:~$ ls
stackoverflow
vagrant@precise64:~$ cd stackoverflow/
vagrant@precise64:~/stackoverflow$ pwd
/home/vagrant/stackoverflow
vagrant@precise64:~/stackoverflow$

2) Убеждаемся, что у нас есть python и он нужной версии

vagrant@precise64:~/stackoverflow$ python -V
Python 2.7.3
vagrant@precise64:~/stackoverflow$

3) Ставим утилиту pip. Это python install packages - специальный менеджер пакетов для python, который существенно облегчает установку и сборку различных библиотек для языка python, да и вообще любых утилит, написанных на python (например, django это по факту именно библиотека на python, а gunicorn - это написанный на python сервер).
Итак:

vagrant@precise64:~/stackoverflow$ sudo apt-get install python-pip
Reading package lists... Done
...
Setting up python-pip (1.0-1build1) ...
vagrant@precise64:~/stackoverflow$

Здесь мы использовали sudo - эта команда позволяет выполнить какие-либо операции от имени администратора (который root). Собственно, когда требуется выполнить какую-либо операцию, требующую прав суперпользователя - используется sudo.

4) Ставим утилиту virtualenv. Это менеджер виртуальных окружений для python. Попробую объяснить, что это означает "нормальным языком". Если просто поставить например django через pip install, то у нас для всей системы будет установлена django последней версии. В то же время, вы вполне можете заниматься разработкой двух проектов, при этом для одного может требоваться django одной версии, а для другого - другой (например, я разрабатываю порядка 6-7 разных проектов, для которых мне одновременно нужны django четырех разных версий, от 1.6 до 1.9). Кроме того, обычно в ходе разработки ставится целая куча сторонних библиотек (штук 20-30 - нормальная ситуация). Таким образом, наша задача - иметь возможность использовать для разных проектов разные версии библиотек python, каждую - со своими библиотеками, так чтобы они не конфликтовали друг с другом. Для этого и используется утилита virtualenv - она дает возможность создать в отдельной папке копию интерпретатора языка python с собстенными настройками и собственным набором библиотек.
Так вот. для начала установим virtualenv с помощью pip:

vagrant@precise64:~/stackoverflow$ sudo pip install virtualenv
Downloading/unpacking virtualenv
...
Successfully installed virtualenv
Cleaning up...
vagrant@precise64:~/stackoverflow$

Пользоваться данной штукой весьма просто - вы просто набиваете virtualenv имя_папки, и в этой папке у вас создается отдельное окружение со своей копией языка python, и вы в любой момент это окружение можете активировать командой source имя_папки/bin/activate и деактивировать командой deactivate. Пробуем:

vagrant@precise64:~/stackoverflow$ virtualenv env
New python executable in /home/vagrant/stackoverflow/env/bin/python
Installing setuptools, pip, wheel...done.
vagrant@precise64:~/stackoverflow$
vagrant@precise64:~/stackoverflow$ source env/bin/activate
(env) vagrant@precise64:~/stackoverflow$
(env) vagrant@precise64:~/stackoverflow$ pip install django
Collecting django
...
Successfully installed django-1.9.4
(env) vagrant@precise64:~/stackoverflow$
(env) vagrant@precise64:~/stackoverflow$ deactivate
vagrant@precise64:~/stackoverflow$

Мы только что создали окружение в папке env, активировали его и поставили туда django. Потом деактивировали ("вышли из окружения"). Теперь у нас есть собственная версия интерпретатора python в папке env/, и там установлен django версии 1.9.4
Обратите внимание, когда мы внутри виртуального окружения - у нас меняется приглашение сервера (добавляется имя, в нашем случае env).

5) Снова активируем окружение и ставим сервер gunicorn:

vagrant@precise64:~/stackoverflow$ source env/bin/activate
(env) vagrant@precise64:~/stackoverflow$ pip install gunicorn
Collecting gunicorn
...
Successfully installed gunicorn-19.4.5
(env) vagrant@precise64:~/stackoverflow$ pip freeze
Django==1.9.4
gunicorn==19.4.5
(env) vagrant@precise64:~/stackoverflow$

Обратите внимание, sudo нам внутри виртуального окружения уже не требуется, поскольку мы ставим питонячьи пакеты не для всех системы, а только для нашего пользователя, так что админские права нам не нужны.
Команда pip freeze показывает список пакетов, установленных в данный момент, вместе с версиями. У нас внутри виртуального окружения установлены только django и gunicorn. Если же выполните pip freeze вне окружения - увидите, что для системы в целом стоит другой набор библиотек.

6) Создаем папку с исходниками проекта, и кладем туда файл с зависимостями:

(env) vagrant@precise64:~/stackoverflow$
(env) vagrant@precise64:~/stackoverflow$ mkdir src
(env) vagrant@precise64:~/stackoverflow$ pip freeze > src/requirements.txt
(env) vagrant@precise64:~/stackoverflow$ cat src/requirements.txt
Django==1.9.4
gunicorn==19.4.5
(env) vagrant@precise64:~/stackoverflow$

Только что мы выполнили команду pip freeze и перенаправили у нее поток вывода в файл requirements.txt. Таким образом в requirements.txt у нас сейчас лежит описание того, какие библиотеки и каких версий нам нужны для данного проекта. Так что теперь на любом сервере мы можем создать виртуальное окружение, выполнить в нем pip install -p requirements.txt и установить ровно тот набор библиотек, который нам нужен. Обратите внимание, что обычно в requirements.txt складывается не полностью весь выхлоп от pip freeze, а только те библиотеки, которые были установлены создательно. Бывает, что ставишь библиотеку "A", а она для работы требует библиотеку "B", и "B" ставится автоматически. Так вот, библиотека "B" в requirements.txt светиться не должна, то есть смотрим на вывод pip freeze, находим там то, что только что установили и добавляем вместе с версией в requirements.txt.

7) В папке src создадим собственно django-проект, который назовем например application (или как хотите можете его назвать :)

(env) vagrant@precise64:~/stackoverflow$ django-admin startproject application src
(env) vagrant@precise64:~/stackoverflow$ ls src
application manage.py requirements.txt
(env) vagrant@precise64:~/stackoverflow$

Команда django-admin у нас появилась в виртуальном окружении после установки django. Папка application - это папка проекта, там вы будете вести собственно разработку. Файл manage.py - это файл управления проектом, дальнейшая административная работа с проектом делается через ./manage.py имя_команды

8) Пробуем запустить сервер django, сначала зайдя в папку src

(env) vagrant@precise64:~/stackoverflow$ cd src
(env) vagrant@precise64:~/stackoverflow/src$ ./manage.py runserver localhost:8080
Performing system checks...

System check identified no issues (0 silenced).

You have unapplied migrations; your app may not work properly until they are applied.
Run 'python manage.py migrate' to apply them.

March 06, 2016 - 15:43:26
Django version 1.9.4, using settings 'application.settings'
Starting development server athttp://localhost:8080/
Quit the server with CONTROL-C.
^C(env) vagrant@precise64:~/stackoverflow$

Вырубить его можно через Ctrl+C. А пока он запущен - можно зайти на localhost:8080 и посмотреть, что оно действительно "чота делает, чота заработало"

9) Пробуем запустить сервер django через wsgi-сервер gunicorn (убиваем тоже с помощью ctrl+C)

(env) vagrant@precise64:~/stackoverflow/src$ gunicorn --reload -b localhost:8080 application.wsgi:application
[2016-03-06 15:57:08 +0000] [1651] [INFO] Starting gunicorn 19.4.5
[2016-03-06 15:57:08 +0000] [1651] [INFO] Listening at:http://127.0.0.1:8080 (1651)
[2016-03-06 15:57:08 +0000] [1651] [INFO] Using worker: sync
[2016-03-06 15:57:08 +0000] [1656] [INFO] Booting worker with pid: 1656
^C[2016-03-06 15:57:26 +0000] [1651] [INFO] Handling signal: int
[2016-03-06 15:57:26 +0000] [1656] [INFO] Worker exiting (pid: 1656)
[2016-03-06 15:57:26 +0000] [1651] [INFO] Shutting down: Master
(env) vagrant@precise64:~/stackoverflow/src$

параметр --reload заставляет gunicorn самостоятельно перезапускаться, когда вы меняется код в джанго-проекте. Джанговский runserver делает это по-дефолту
параметр -b позволяет указать, какие ip-адреса мы слушаем и на каком порту. В нашем случае - localhost порт 8080
в конце мы указываем путь до callback-функции, которую должен вызывать gunicorn каждый раз, когда ему приходит запрос. мы указали на функцию application в файле application/wsgi.py

10) Пробуем то же самое, но с использованием четырех воркеров (то, что я рассказывал про prefork)

(env) vagrant@precise64:~/stackoverflow/src$ gunicorn --reload -b localhost:8080 application.wsgi:application -w 4
[2016-03-06 15:57:31 +0000] [1662] [INFO] Starting gunicorn 19.4.5
[2016-03-06 15:57:31 +0000] [1662] [INFO] Listening at:http://127.0.0.1:8080 (1662)
[2016-03-06 15:57:31 +0000] [1662] [INFO] Using worker: sync
[2016-03-06 15:57:31 +0000] [1667] [INFO] Booting worker with pid: 1667
[2016-03-06 15:57:31 +0000] [1669] [INFO] Booting worker with pid: 1669
[2016-03-06 15:57:31 +0000] [1679] [INFO] Booting worker with pid: 1679
[2016-03-06 15:57:31 +0000] [1681] [INFO] Booting worker with pid: 1681
^C[2016-03-06 15:57:36 +0000] [1662] [INFO] Handling signal: int
[2016-03-06 15:57:36 +0000] [1681] [INFO] Worker exiting (pid: 1681)
[2016-03-06 15:57:36 +0000] [1667] [INFO] Worker exiting (pid: 1667)
[2016-03-06 15:57:36 +0000] [1669] [INFO] Worker exiting (pid: 1669)
[2016-03-06 15:57:36 +0000] [1679] [INFO] Worker exiting (pid: 1679)
[2016-03-06 15:57:36 +0000] [1662] [INFO] Shutting down: Master
(env) vagrant@precise64:~/stackoverflow/src$

Так оно будет работать гораздо быстрее

11) Создадим две папки - collected_static и media (первая - для статики, вторая - для файлов, загруженных будущими пользователями). Обе папки у нас впоследствии будут обслуживаться nginx-ом

(env) vagrant@precise64:~/stackoverflow/src$ cd ..
(env) vagrant@precise64:~/stackoverflow$ mkdir collected_static media
(env) vagrant@precise64:~/stackoverflow$ ls
collected_static env src media
(env) vagrant@precise64:~/stackoverflow$

Объсняю, зачем это нужно. Ну, с папкой media всё должно быть понятно - если пользователь загружает на сервер картинку (например, собственную аватарку), то django будет класть эту картинку в папку media (мы это позже настроим). А nginx соответственно отвечать на запросы к этой картинке, забирая ее из папки media. В случае со статикой практически то же самое, за исключением одного нюанса - django будет наполнять папку collected_static с помощью команды manage.py collectstatic (настроим в следующем пункте)

12) Настраиваем статику. Создаем папку static внутри проекта (в папке src)

(env) vagrant@precise64:~/stackoverflow$ cd src/
(env) vagrant@precise64:~/stackoverflow/src$ ls
application db.sqlite3 manage.py requirements.txt
(env) vagrant@precise64:~/stackoverflow/src$ mkdir static
(env) vagrant@precise64:~/stackoverflow/src$ ls
application db.sqlite3 manage.py requirements.txt static
(env) vagrant@precise64:~/stackoverflow/src$

Именно в эту папку мы будем класть какие-либо картинки, файлы стилей и прочее, то, что нам нужно будет для отображения страниц проекта (я говорю не про верстку, то есть не .html-файлы, а именно файлы ресурсов (картинки)).
Теперь настраиваем django-проект так, чтобы он искал статические файлы в папке static, и складывал их специально для nginx в папку collected_static. Для этого лезем редактировать настройки проекта (файлы application/settings.py). Дописываем в конец файла:

STATIC_URL = '/static/'
STATIC_ROOT = '/home/vagrant/stackoverflow/collected_static/'
STATICFILES_DIRS = ('/home/vagrant/stackoverflow/src/static/', )

Прописываете пути к своим папкам. Настройка STATICFILES_DIRS указывает django-проекту, где именно в исходниках он должен искать статику. Настройка STATIC_ROOT показывает, куда он должен скопировать всю эту статику по команде collectstatic. Такая хитрожопая схема копирования статики применяется в django потому, что некоторые python-библиотеки являются django-приложениями и притаскивают собственный набор картинок и прочего. Таким образом, когда мы делаем manage.py collectstatic - мы на самом деле копируем в нужную для nginx папку не только наши собственные файлы, но и все прочие картинки, использующиеся другими django-приложениями, включенными в наш проект.

13) Собственно, давайте попробуем collectstatic. Кладем в static пустой файлик для теста и запускаем.

(env) vagrant@precise64:~/stackoverflow/src$ touch static/blabla.gif
(env) vagrant@precise64:~/stackoverflow/src$ ls static/
blabla.gif
(env) vagrant@precise64:~/stackoverflow/src$ ./manage.py collectstatic

You have requested to collect static files at the destination
location as specified in your settings:

/home/vagrant/stackoverflow/collected_static

This will overwrite existing files!
Are you sure you want to do this?

Type 'yes' to continue, or 'no' to cancel: yes
Copying '/home/vagrant/stackoverflow/src/static/blabla.gif'
Copying '/home/vagrant/stackoverflow/env/local/lib/python2.7/site-packages/django/contrib/admin/static/admin/img/calendar-icons.svg'
...
57 static files copied to '/home/vagrant/stackoverflow/collected_static'.
(env) vagrant@precise64:~/stackoverflow/src$ ls ~/stackoverflow/collected_static/
admin blabla.gif

Как видите, django скопировала не только наш файлик, но и еще 56 файлов с различной фигней, которая нужна для работы приложения django-admin (оно включено в проект по умолчанию). Если впоследствии добавим еще какое-нибудь стороннее django-приложение в проект - оно обязательно притащит еще какое-то количество своих статических файлов, которые мы точно также сможем одной командой скинуть туда, где их сможет раздавать nginx

14) С установкой и предварительной настройкой django мы наверное всё. Поставим утилитку tree и посмотрим, что у нас примерно должно было получиться в смысле файловой структуры

(env) vagrant@precise64:~/stackoverflow$ sudo apt-get install tree
...
(env) vagrant@precise64:~/stackoverflow$ tree -L 2
.
|-- collected_static
| |-- admin
| `-- blabla.gif
|-- env
| |-- bin
| |-- include
| |-- lib
| |-- local
| `-- pip-selfcheck.json
|-- src
| |-- application
| |-- db.sqlite3
| |-- manage.py
| |-- requirements.txt
| `-- static
`-- uploads

Вот как-то так. Обращаю внимание - это не разработка, это только предварительная установка и настройка django так, чтобы впоследствии можно было сделать из этого нормальный проект.



Установка и настройка nginx

1) Собственно, всё просто и банально. Ставим с помощью apt-get. (Если apt-get не найдет каких-то пакетов, вам поможет apt-get update)

(env) vagrant@precise64:~/stackoverflow$ sudo apt-get install nginx
Reading package lists... Done
...
(env) vagrant@precise64:~/stackoverflow$

2) Всё, nginx установлен и запущен в данный момент. Пробуем его остановить, запустить, ребутнуть...

(env) vagrant@precise64:~/stackoverflow$ sudo /etc/init.d/nginx stop
Stopping nginx: nginx.
(env) vagrant@precise64:~/stackoverflow$ sudo /etc/init.d/nginx start
Starting nginx: nginx.
(env) vagrant@precise64:~/stackoverflow$ sudo /etc/init.d/nginx restart
Restarting nginx: nginx.
(env) vagrant@precise64:~/stackoverflow$ sudo /etc/init.d/nginx reload
Reloading nginx configuration: nginx.
(env) vagrant@precise64:~/stackoverflow$

3) Пробуем заглянуть наhttp://localhost/ и убедиться, что nginx работает

4) Основной конфиг nginx лежит в папке /etc/nginx/nginx.conf, но он нам особо не нужен - лучше мы создадим конфиг для своего проекта в /etc/nginx/conf.d/stackoverflow.conf (попутно убиваем дефолтный конфиг сайта, который идет вместе с сервером). После чего убеждаемся, то мы ничего не сломали и nginx будет работать

(env) vagrant@precise64:~/stackoverflow$ sudo touch /etc/nginx/conf.d/stckoverflow.conf
(env) vagrant@precise64:~/stackoverflow$ sudo rm /etc/nginx/sites-available/default
(env) vagrant@precise64:~/stackoverflow$ sudo rm /etc/nginx/sites-enabled/default
(env) vagrant@precise64:~/stackoverflow$ sudo /etc/init.d/nginx configtest
Testing nginx configuration: nginx.
(env) vagrant@precise64:~/stackoverflow$
(env) vagrant@precise64:~/stackoverflow$ sudo /etc/init.d/nginx restart
Restarting nginx: nginx.

5) Правим конфиг, за основу берем примерно вот такой файликhttps://github.com/sat2707/web/blob/master/tcp_servers/stackoverflow.conf (предполагается, что сам django-сервер, сам или через gunicorn будет запущен у вас на порту 8080, а nginx будет слушать на дефолтном 80м порту, и проксировать часть запросов на порт 8080 плюс раздавать статические файлы при запросе к урлам /static/ и /media/)



Собственно всё, это всё, что вы должны сделать к среде. Довольно объемно, но весьма просто, особенно учитывая, что у вас есть готовые рецепты. Удачи с ДЗ, если есть вопросы - задавайте в каментах, либо в личке.

Всем, кто до сих пор довольно поверхностно представляет себе синтаксис языка python - в обязательном порядке сюдаhttp://ru.diveintopython.net/toc.html .




Лекция 16 марта 2016
Основы веб-разработки (первый семестр)
https://s.mail.ru/dhV5uzBoEDMN/stackoverflow.zip https://s.mail.ru/352jXFCqPXAJ/stackoverflow%202.zip https://s.mail.ru/53BYSLLehiZw/web3.pdf


ДЗ и описания будут позже, после обновления поста сделаю рассылку


UPD.

Итак, ДЗ. Ваша задача - создать внутри вашего django-проекта несколько приложений, описать в них простейшие модели для основных вещей, которые будут в вашем проекте, добавить их в админку django и реализовать простенькие странички для показа объектов этих моделей.

Давайте я вкратце напомню, что в проекте должен быть реализован следующий минимум -
1. Наличие авторизации
2. Наличие создаваемого пользователем контента
3. Комментарии
4. Пользовательские действия «в одно нажатие» (лайк, дизлайк, вроде того)
5. Проверка прав

Поясняю по каждому пункту:
1. Наличие авторизации - имеется ввиду возможность пользователя залогиниться и разлогиниться на проекте, реализованная вами. Логин в админку django - это не про то (но пока что можете использовать его для того единственного пользователя, которого мы создали). Позже мы реализуем собственные страницы логина и выхода с сайта.
2. Наличие создаваемого пользователем контента - например, пост в блогодвижке. Или фотогалерея. Или заданный на stackoverflow вопрос. Всё то, что пользователь по идее может запостить на сайт самостоятельно.
3. Комментарии - здесь я подразумеваю не обязательно именно каменты, я имею ввиду любую модель данных, которая тоже создается пользователем, и бессмысленная сама по себе, без того объекта, к которому она "привязана". Тот же комментарий, например, обязательно привязан к посту, к которому его написали. Или вопрос на stackoverflow привязан к ответу. Если же вы, например, пишете сайт-аукцион, то к аукциону там будет привязаны ставки. Надеюсь, эта мысль ясна.
4. Пользовательские действия в "в одно нажатие" - проще всего это объяснить с помощью лайков. Пользователь лайкнул пост, в посте должен увеличиться счетчик лайков на один, плюс мы должны запомнить, что именно этот юзер лайкнул именно этот пост. То есть, собственно контента (какого-то текста) у лайка нет. Важен сам факт его наличия. Так же, как и в предыдущем пункте - если вы вместо лайков придумаете нечто другое, похожее по функционалу - это ок.
5. Проверка прав - имеется ввиду тот факт, что если пользователь создал пост - то и редактировать или удалить его может только этот пользователь. Ну и в отношении всего остального также.

Если у вас сомнения в том, как построить модель для своего проекта, подходит ли для проекта выбранная вами тематика - пишите здесь или в личку, помогу. Собственно, многие из вас так и делают, получают ответ и им становится проще :)


Теперь про ДЗ более подробно - вам нужно реализовать модели и странички для того, что я указал в пп. 2 и 3 (создаваемый юзером контент, основной и то, что я назвал "комментариями". Под страничками я, естественно, имею ввиду не просто html-страницы, а возможность зайти на сайт и увидеть тот или иной объект или группу объектов.


Пример того, что мы делали на лекции - в аттаченных файлах выше, плюс вот вам небольшая памятка:


0. Работа с проектом.
Все действия с manage.py стоит выполнять из папки src (там же собственно manage.py и лежит). При этом нужно находиться в питоньем виртуальном окружении (source env/bin/activate). Просто убеждайтесь что в приглашении командной строки у вас есть в начале обозначение (env).


1. Приложения в django.

Всё просто. Приложение создается командой ./manage.py startapp имя-приложения, после чего имя-приложения нужно добавить в переменную INSTALLED_APPS в настройках (settings.py).
Внутри проекта создастся одноименная папка, в ней мы создаем еще две - templates и static (для шаблонов приложения и для статических файлов). Плюс файл для роутинга urls.py
Создайте себе как приложение например core (./manage.py startapp core), чтобы сложить туда шаблоны и статику, которые нужны для всего проекта (статики у вас пока наверное не будет, а вот базовый шаблон в ходе работы с ДЗ появится).
Модели описываем в файле models.py, контроллеры - views.py, урлы - в urls.py.
Как правильно делить проект на приложения - как минимум создайте отдельное приложение для той модели данных, которая будет у вас основной (у кого-то блог, у кого-то вопрос, у кого-то аукцион итп). И для второй модельки, которая привязана к первой. А большего на данном этапе вам и не нужно, так что у вас получается три приложения (вместе с core). Если кто-то ну очень уверен что эти две модели данных логически неотделимы друг от друга - ну пусть будет не три приложения, а два, вполне ок.


2. Описываем модели данных.

Это делается в файлах models.py, подход такой - создаем класс-наследник от models.Model, в качестве аттрибутов описываем ему необходимые поля.
Про различные типы полей можно почитать например тут https://docs.djangoproject.com/en/1.9/ref/models/fields/ (официальная дока) или тут http://djbook.ru/rel1.8/ref/models/fields.html (её перевод)
Вкратце, наиболее употребимы следующие поля (названия у них вполне доносят смысл):
models.CharField - строк, обязателен аргумент max_length - максимальная длина строки
models.TextField - для больших текстов (например, название поста - CharField, текст поста - TextField)
models.IntegerField - для целых чисел
models.FloatField - для дробных чисел
models.DateField - для дат (date), необязательный аргумент auto_now_add - "всегда автоматически ставить текущую дату при создании"
models.DateTimeField - для дат вместе со временем (datetime), аргумент auto_now_add аналогично DateTime
models.ForeignKey - id какой-либо другой модели, обязательный параметр - имя модели

Про models.ForeignKey - данное поле - это возможность привязать одну модель к другой. Об этом буду более подробно рассказывать на следующих лекциях, сейчас же - просто пример:

(в приложении blogs)

class Post(models.Model):
title = models.CharField(max_length=255)
text = models.TextField()

(в приложении comments)

class Comment(models.Model):
text = models.TextField()
post = models.ForeignKey('blogs.Blog')

Вот так можно создать простейшие модели блога и комментария к нему.
Благодаря полю ForeignKey мы указываем принадлежность одного объекта модели к другому. То есть, допустим у нас переменная p - объект класса пост в блоге, а переменная c - объект класса комментарий, тогда мы сможем сделать подобное:
c.post.title (заголовок поста, к которому создан камент c)
p.comment_set.all() (list из всех комментариев к посту p)

Подробней об этом я расскажу вживую, сейчас же можно просто пользоваться этой частью функционала

Если для модели нужно хранить дату ее создания, выручает created_at = models.DateTimeField(auto_now_add=True)
Лучше хранить дату создания вообще для всего :)


3. Создаем нужные структуры в базе данных.
Здесь особо не о чем рассказывать - вызываем последовательно ./manage.py makemigrations и ./manage.py migrate - первая команда заставит django записать сделанные вами изменения моделей в виде миграций (это просто скрипты на питоне в папке migrations), вторая команда - применит к базе данных те миграции, которые еще не применялись.
Если потом добавим поля к модели - нужно будет снова запустить последовательно первую и вторую команду, чтобы эти поля добавились в структуру данных в базе.


4. Выводим наши модели данных в админку.
Здесь всё очень просто - приложение django.contrib.admin уже включено в новом проекте по умолчанию, и прекрасно работает. Просто находим в приложении файл admin.py, импортируем в нем все модели нашего приложения и подключаем модель к админку функцией admin.site.register

Например:

from django.contrib import admin
from .models import Post

admin.site.register(Post)

С этого момента в админке мы сможем управлять всеми объектами, созданными по этой модели.
Кстати, в саму админку можно попасть по ссылке localhost/admin/, предварительно создав первого (и пока единственного) пользователя сайта командой ./manage.py createsuperuser


5. Создаем базовый шаблон представлений (основной html-шаблон сайта, грубо говоря).
Про шаблоны в django можно почитать к примеру тут http://djbook.ru/rel1.8/ref/templates/language.html
Пусть это будет файлик base.html в папке templates приложения core. Пусть в нем будет как минимум два блока - title и content (первый для заголовка текущей просматриваемой страницы, второй собственно для содержимого. Блоки вставляются тегом {% block имя-блока %}{% endblock %}

Все остальные шаблоны будут наследоваться от этого, то есть будут начинаться со строки {% extends "base.html" %}, а блоки title и content будут в них переопределяться (то есть тот же block-endblock, просто с контентом посередине, типа {% block title %}Главная страница сайта{% endblock %})


6. Создаем список роутов (шаблонов ссылок) в каждом приложении и подключаем его в основной urls.py
Почитать можно тут http://djbook.ru/rel1.8/topics/http/urls.html#including-other-urlconfs

Пока что контроллеров у нас нет, просто создаем каркас для будущих урлов проекта. Можете ориентироваться на файлик application/urls.py и news/urls.py в моем примере (том, что я писал в течение лекции). Почитать про это можно тут

Например:

(blogs/urls.py)

from django.conf.urls import url

urlpatterns = [
]

(applications/urls.py)

...
urlpatterns = [
url(r'^admin/', admin.site.urls),
url(r'^blogs/', include('blogs.urls', namespace="blogs")),
]


7. Последовательно создаем нужные контроллеры и шаблоны, контроллеры прописываем в urls.py приложений
Почитать можно тут http://djbook.ru/rel1.8/ref/class-based-views/index.html
Предполагаю что вам нужно как минимум иметь, для вашей основной модели:
- Страничку со всеми объектами модели (список постов)
- Страничку с отдельным объектом модели (отдельный пост + список комментариев)

Используем django class-based views (например, DetailView из примера - это и есть class-based-view)
Фактически, вам понадобится только DetailView и ListView

Как их использовать, должно быть видно из примера, сейчас же подскажу кратко:

Для отображения списка объектов используем ListView, его параметры:
model - имя модели, список объектов которой хотим показывать (предварительно нужно ее импортировать)
template_name - имя шаблона (т.н. представления), с помощью которого хотим показать список

В шаблоне у нас будет список объектов в переменной {{ object_list }}, показать каждый можно в цикле (тег {% for %})

Пример:

(blogs/views.py)

class PostList(ListView):
template_name = "blogs/post_list.html"
model = Post

(blogs/templates/blogs/post_list.html) - кто первый ответит в каментах, зачем мы создаем еще одну папку blogs - получит +1 балл :)

{% extends "base.html" %} (файл base.html будет последовательно искаться во всех приложениях, пока не будет найден в приложении core)

{% block title %}Список постов{% endblock %}

{% block content %}
{% for post in object_list %}
<div>
<div>{{ post.title }}</div>
<div>{{ post.text }}</div>
</div>
{% endfor %}
{% endblock %}

(blogs/urls.py)

from .views import *

urlpatterns = [
url(r'^posts/$', PostList.as_view(), name="post_list"),
]

Таким образом, зайдя на урл вида localhost/blogs/posts/ , вы должны увидеть список постов (можно добавить несколько через админку и так и проверять)


Страница одного объекта делается через DetailView, она есть в примере
Добавлю только, что методы, предоставляемые нам полем ForeignKey можно использовать и в шаблонах - то есть {% for comment in object.comment_set.all %}...{% endfor %} вполне будет работать, если в переменной object в шаблоне у нас лежит объект класса Post


7. Небольшой справочник по HTML и тегах шаблонизатора django

Для тех, кто не силен в верстке - мы посвятим ей отдельную лекцию, пока же не заморачиваемся на красоты, так что можно вообще использовать всего два тега, по идее их хватит
<div>какой-то текст<div> - текст будет показан на отдельной строке
текст текст будет являться ссылкой, которая будет вести на адрес, описанный в href

Теги и фильтры django-шаблонов можно найти здесь http://djbook.ru/rel1.8/ref/templates/builtins.html , по идее вам оттуда сейчас нужны: extends, block, for, url да и должно хватить.



ДЗ#3: Работа с моделями и объектами моделей
Основы веб-разработки (первый семестр)
Здесь - та инфа, которая вам будет нужна по моделям Django для подготовки третьего ДЗ


Правильный импорт settings

В ходе подготовки к ДЗ вам потребуется настройка AUTH_USER_MODEL, которую нужно будет брать из настроек проекта. Настройки проекта импортируются так:


from django.conf import settings


При этом импортируется не просто файлик settings.py в исходном нетронутом виде, django дополнительно дозаполняет его дефолтными настройками

Использование русских букв в скриптах на python

В случае использования русских букв в начало файла (первой строкой) добавляется:


# coding: utf-8


Консоль django

Чтобы всяко поиграться с выборками, проверить какие-то гипотезы, итп - можно использовать консоль django

manage.py shell

Данная команда открывает терминал python, и импортирует в нём полностью всё окружение, необходимое для работы проекта (то же самое, что делает django-сервер перед стартом).
Внутри можно импортировать уже нужные модели, контроллеры и всё прочее, ну и интерактивно всё это опробовать.

ipython

Это пакет на python, сам по себе являющийся более удобным python-терминалом (присутствует autocompletion по "TAB", история команд, итп).
Ставим его с помощью pip install ipython, после чего manage.py shell начнёт автоматом его подхватывать.

manage.py dbshell

Если кому-то понадобится - данная команда берёт все нужные настройки соединения с БД из settings.py и вываливает вас в терминальный клиент базы данных, где уже на языке SQL можно пообщаться с БД напрямую.

Полезные методы у объекта модели

__unicode__

Метод __unicode__ есть в python буквально для всего, и вызывается тогда, когда необходимо получить представление объекта в виде строки. То есть, если вы просто печатаете что-либо через print - вызывается именно метод __unicode__ у переменной, которую вы печатаете. Если админка django показывает список объектов - вызывается он же. В шаблоне, когда вы просто выводите переменную ( {{ post }} ) - тоже вызывается он.
Метод __unicode__ должен возвращать переменную в строковом представлении. Ближайший пример:


class M(models.Model):
title = models.CharField()
def __unicode__(self):
return self.title


Если необходимо, можно отдавать и более комплексный результат в __unicode__. Например:


class M(models.Model):
title = models.CharField()
created_at = models.DateTimeField()
def __unicode__(self):
return u'{} от {}'.format(self.title, self.created_at)


Meta

Класс Meta содержит некоторую необязательную информацию о модели в целом. Например:

verbose_name, verbose_name_plural
Данные аттрибуты использует админка Django, чтобы выяснить, как показывать название модели в единственном и множественном числе. Содержат строки.
ordering
Способ сортировки списка моделей по умолчанию. Является список из названия полей.

Например:


class Article(models.Model):
title = models.CharField()
created_at = models.DateTimeField()
class Meta:
verbose_name = u'Новость'
verbose_name_plural = u'Новости'
ordering = ('-created_at', )


Теперь в админке данная модель будет называться "Новость", в списках - "Новости", по умолчанию мы всегда будем получать выборку, отсортированную по дате создания в обратном порядке (за это отвечает "-" перед названием поля

QuerySet, objects, выборка объектов из БД

QuerySet - это метод в Django, отвечающий за представление запроса к базе данных. Когда мы создаем объект в базе - используется QuerySet, когда выбираем из базы список объектов - используется он же. Всегда при работе с базой используется QuerySet.
Кроме того, у каждой модели есть т.н. Manager - это объект, который вызывается по умолчанию при необходимости выдрать объекты из базы. Он лежит в аттрибуте objects и возвращает QuerySet по умолчанию для данной конкретной модели.

Пример:


Article.objects.all() - формируем запрос на выборку всех объектов Article из БД


QuerySet - Lazy object. То есть, само по себе обращение к QuerySet объекты из базы не вытаскивает, а лишь формирует внутри себя необходимые структуры для выполнения запроса (фильтры, сортировки, различные маппинги полей и тому подобное).
Непосредственно обращение к базе данных происходит при явном вызове. Например, при попытке напечатать QuerySet с помощью print - произойдет запрос к базе данных. При попытке итерироваться по объектам в QuerySet (например, в шаблоне через {% for %}) - произойдет запрос.

Пример:


q = Article.objects.all() - БД не трогаем, лишь сформировали запрос
q = q.filter(title="lalala") - БД всё еще не трогаем, добавили в запрос фильтр по полю title
q = q.order_by('created_at') - БД всё еще не трогаем, добавили в запрос сортировку по полю created_at

А вот сейчас уже запросы к БД
print q
l = list(q)
for obj in q: print obj


Как видно из предыдущего примера, некоторые методы QuerySet возвращают его же, и таким образом могут быть объединены в цепь. То есть, вполне валидно вот так


q = Article.objects.filter(title="lalala").order_by('created_at')[:10] - отсортировали по полю title, упорядочили по полю created_at и взяли десять первых объектов из запроса


filter

QuerySet можно фильтровать множеством различных способов, для чего используется метод filter. На вход в качестве имен параметров подаются имена полей модели, в качестве значений - то, с чем мы хотим сравнить эти поля в запросе.
Кроме того, существует принятая в Django нотация через "__" (два подчеркивания).
Применяется она для двух различных случаев:

Для использования одного из фильтров Django
Есть возможность не просто делать выборку по принципу "возьмем все новости, у которых title равен чему-либо", но и более сложные штуки вроде "возьмем все новости, у которых дата создания меньше данной", "все, у которых количество просмотров больше определенного", "все, созданные в ноябре этого года", "все, у которых в тексте есть слово 'Путин'" и тому подобное. Для этого к названию поле через __ присоединяется один из встроенных фильтров Django. Он описывает, какое именно сравнение мы хотим произвести между данным полем и значением. Лучше всего можно понять это на примере

Article.objects.filter(title="lalala") - все, где title РАВЕН lalala
Article.objects.filter(title__contains="lalala") - все, где title СОДЕРЖИТ lalala
Article.objects.filter(title__icontains="lAlAlA" - все, где title СОДЕРЖИТ lalala, независимо от регистра
Article.objects.filter(created_at__lt=datetime.datetime(2016, 3, 10)) - все объекты, созданные до 10 марта (поле created_at МЕНЬШЕ datetime.datetime(2016, 3, 10)
Article.objects.filter(likes_count__gte=50) - все, где поле likes_count БОЛЬШЕ-ЛИБО-РАВНО 50

Думаю, суть понятна.

Для сравнения полей связанных моделей
Представим, что у нас есть модель Post, и на него через ForeignKey ссылается модель Comment.
Тогда через comment__имя-поля мы можем фильтровать комментарии по значениям из связанной модели. На пример:


Comment.objects.filter(post__title="lalala") - все комментарии, где у связанного поста title равен lalala


Комбинирование фильтров и полей связанных моделей
Можно делать и это. Например:


Comment.objects.filter(post__likes_count__gt=50) - все комментарии, где у связанного поста поле likes_count больше 50


Кроме того, можно следовать по цепочке таких связок на сколько угодно моделей вперед. К примеру, пусть модель Post ссылается на модель Blog. Тогда можно:


Comment.objects.filter(post__blog__name="Фоточки") - все комментарии, привязанные к постам, которые лежат в блогах с полем name равным "Фоточки"


Фильтр по связанной модели

Допустим, у нас у модели Post есть автор (модель пользователя) в поле Author (author=models.ForeignKey(settings.AUTH_USER_MODEL).
И допустим, что у нас есть переменная request.user (текущий пользователь). Тогда мы можем сделать так:


Post.objects.filter(author=request.user)
Post.objects.filter(author=request.user.id)


То есть, для ForeignKey фильтр работает и с объектом модели, и с id этого объекта.

order_by

Кроме того, база данных предоставляет нам возможность сортировать выборку по нужному полю (или нескольким полям последовательно). Django же дает нам воспользоваться этим с помощью метода order_by. На вход этого метод принимает имена полей в качестве аргументов, например:


Post.objects.order_by('title') - сортируем посты по заголовку
Post.objects.order_by('-title') - сортируем посты по заголовку в обратном порядке
Post.objects.order_by('created_at', 'title) - сортируем сначала по дате создания, а внутри одинаковых дат - по заголовку


С order_by можно вертеть точно такие же фокусы через "__", как и для метода filter. То есть, мы можем вот такое:


Comment.objects.order_by('post__title') - сортируем каменты по названию связанного поста
Comment.objects.order_by('post__author__username') - сортируем каменты по логины пользователя, который создал пост, в котором опубликован камент! :)


Срезы

Список моделей можно выдрать из БД не полностью, а только часть. Для этого применяется та же нотация срезов, что и в целом в python. Покажу на примере:


Blog.objects.all()[:10] - десять первых блогов из выборки
Blog.objects.all()[25:30] - выборка блогов с 25го по 30й


Важно понимать, что вообще без сортировки мы берем десять первых блогов просто в порядке создания (или, если угодно, считайте, что по умолчанию всё сортируется по id).
Срезы обычно используются для вывода объектов постранично (с 1 по 10, с 10 по 20, ну и так далее)

Комбинируем всё вместе

Просто комплексный пример


Comment.objects.filter(post__author=request.user).order_by('blog__title', '-likes_count')[:10]
Все комментарии к постам текущего пользователя, упорядоченные сначала по названию поста, а внутри одинаковых названий постов - по количеству лайков в порядке убывания, первые десять комментариев


Забирание одного конкретного объекта из БД

get

Метод get возвращает нам один объект из базы данных по определенному фильтру (формат такой же, как и у filter). Использует чаще всего фильтрация по id:


Post.objects.get(id=10) - хотим получить пост с id=10


В случае, если такого объекта в базе нет, или если таких больше одного - произойдет ошибка (Post.DoesNotExist, и еще какая-то, не помню :)
А значит, если вы делаете это внутри view - получите ошибку сервера. Как с этим справиться - читаем дальше

get_object_or_404

Это не метод QuerySet-а, а вспомогательная функция, лежит в django.shortcuts (кстати, там собраны и другие весьма полезные штуки).
Эта функция получает на вход QuerySet, и список параметров, аналогичных методу filter). И либо возвращает найденный объект, либо провоцирует возникновение ошибки Http404. Этот класс ошибок Django ловит самостоятельно в процесе выполнения запроса, и возвращает страницу "Не найдено" (а это намного лучше, чем "ошибка сервера"). Таким образом, внутри любого из этапов обработки запроса (грубо говоря, внутри view), мы можем сделать так:


from django.shortcuts import get_object_or_404
импортируем get_object_or_404:


и где-нибудь в коде view:


post = get_object_or_404(Post.objects.all(), id=10)
либо получим пост с id=10 в переменную post, либо пользователь увидит страницу "Не найдено"


а можем и так, например:


post = get_object_or_404(Post.objects.filter(author=request.user), id=10)
берем все посты, где текущий юзер является автором, ищем среди них один с id=10
страницу "Не найдено" пользователь получит, если а) он не является автором поста с id=10 б) такого поста вообще нет в базе


first, last

Допустим, нам пофигу, встречается ли такой объект в выборке один или несколько раз, или его вообще там нет. И допустим, что мы в случае отсутствия объекта вообще не хотим никаких ошибок, а просто хотим None. Запросто, за это и отвечают методы first и last.
Проще всего на примере:


Post.objects.filter(title="lalala").first() - получаем первый пост в выборке, у которого title равен "lalala"
Post.objects.filter(title="lalala").first() - аналогично, последний пост с заданными условиями


Естественно, можно комбинировать first и last с сортировкой и фильтрами:


Post.objects.filter(author=request.user).order_by('-like_count').first() - получаем пост текущего юзера с максимальным количеством лайков, или None, у него вообще нет постов



Создание и редактирование объектов в БД

Изменение аттрибутов моделей
Происходит предельно просто - все поля модели есть у каждого объекта этой модели, и равны значениям из базы данных. Их можно переопределять. Важно понимать, что в базе автоматически ничего в этом случае не сохраняется. Сохранение отредактированной информации инициируется специальным методом save


post = Post.objects.first() - взяли первый попавшийся пост из базы
print post.title - напечатали его заголовок
post.title = u"Я взрослый мужик, я хочу пива, а не писать статьи" - отредактировали заголовок у поста
В БАЗЕ ДАННЫХ НИЧЕГО НЕ ПОМЕНЯЛОСЬ ПОКА ЧТО
post.save() - пост отредактировался в базе данных

post = Post() - а вот взяли и просто создали объект поста, его пока нигде нет, кроме как у нас в коде
print post.title - в заголовке ничего нет, вернее там лежит значение, указанное в качестве defaul для поля в models.py
post.title = u"А с другой стороны, я высадил уже четыре банки и больше не лезет. Старею." - установили заголовок
post.save() - новый объект создался в базе данных

post = Post(title=u"А и пофиг, выпью пятую!") - создали объект поста сразу с предустановленным заголовком
В БАЗЕ ПОКА НИЧЕГО НЕ ПОМЕНЯЛОСЬ
post.save() - а вот сейчас сохранили новый пост в базу


save
Данный метод используется для сохранения объектов в базу (раскрыто примером выше). У нас может быть только что созданный объект, либо уже существующий в базе. Определяется это наличием id у объекта (аттрибут id равен либо None, либо какому-то числу). Если id пуст - создаем новый объект, если нет - редактируем существующий (тот, который в базе лежит с этим id).
В случае создания объекта к связанной модели - просто подставляем объект в соответствующее поле. Например, создадим камент к посту с id=10:


post = Post.objects.get(id=10) - выдрали из базы пост
comment = Comment(post=post, title=u"Я убер-камент, вы облайкаетесь!") - создали объект камента с предзаполненными полями, в том числе и с полем post, которое теперь указывает на наш пост
comment.save() - сохранили



Связанные модели

обратная связь, related_name
По умолчанию, когда мы привязываем одну модель к другой, создается в том числе "обратная выборка" у модели, к которой мы что-то привязываем. То есть, например:


class Post(models.Model):
...

class Comment(models.Model):
post=models.ForeignKey('blogs.Post')


У нас не только в каждом комментарии будет поле post, в котором валяется тот пост, к которому привязан камент. В объекте поста появляется аттрибут comment_set, который является QuerySet-ом, заранее отфильтрованным по посту.
То есть, post.comment_set.all() равнозначно такому - Comment.objects.filter(post=post) (и кстати, с ним можно творить всё, описанное выше - это такой же QuerySet).

Как видите, по умолчанию Django берет, имя модели, приводит в нижний регистр и добавляет _set. Такое поведение можно изменить, добавив параметр related_name. Например, если мы опишем поле как post=models.ForeignKey('blogs.Post', related_name='comments'), то у постов появится аттрибут comments вместо comment_set. Это красивее.

Кроме того, эта возможность пригодится вам, когда вы будете создавать несколько связей с одной и той же моделью. Например:


class Post(models.Model):
author = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='posts')

class Comment(models.Model):
author = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='comments')


Вот в этом случае вы можете запросто сделать request.user.posts, request.user.comments - все посты или комментарии текущего пользователя.

Представим такую ситуацию - у вас есть модерация, и соответственно у поста есть не только автор, но и модератор, который пост опубликовал. А значит, вы имеете две связи поста с пользователем. Тогда вам придется задать related_name, иначе Django откажется создавать такую связь:


class Post(models.Model):
author = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='created_posts')
moderator = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='published_posts')


А у текущего пользователя вы сможете заиметь две выборки постов - user.created_posts (посты, опубликованные юзером) и user.published_posts (посты, которые юзер разрешил к публикации в качестве модератора).

Фильтр по обратной связи

Есть возможность, которая не всегда очевидна - фильтр модели по обратной связи с другой моделью. На примере:


Post.objects.filter(comments__title__icontains=u"Путин") - все посты, в которых есть хотя бы один комментарий, содержащий в заголовке слово "Путин" (кстати, кто-нибудь в курсе, кто это? часто про этого мужика слышу).


Имейте ввиду, в этом случае, если в каком-либо посте есть два таких комментария, то и пост вы получите в выборке два раза (особенность работы СУБД, на втором курсе вам про это расскажут лучше меня).
Чтобы избежать такой ситуации - у QuerySet есть метод distinct (выборка только записей, уникальных по какому-либо полю, грубо говоря исключение дубликатов из выборки).
То есть, выборка будет такой:


Post.objects.filter(comments___title__icontains=u"Путин").distinct("id") - выбираем то же, что и до этого, но следим, чтобы в выборке не было постов с одинаковым id



Справочное чтиво

Здесь https://docs.djangoproject.com/en/1.9/ref/models/fields/ сначала есть описание всех возможных аргументов для полей в models.py, потом - все возможные типы полей.
Здесь https://docs.djangoproject.com/en/1.9/ref/models/querysets/#id4 - все возможные фильтры для полей (а в целом там описание всех возможных методов QuerySet-а)
И тот и другой источник есть в разделе документации на http://djbook.ru/ на русском языке. Либо гугл в помощь :)


Пожалуй, пока всё. В комментариях можете задавать вопросы. Если вы их не задаёте, то я считаю, что по этой теме всем всё понятно :)
Если задаёте - дополняю пост, не нарушая существующего формата.

ДЗ#4: Верстка
Основы веб-разработки (первый семестр)
Итак, ДЗ#4 - здесь о той его части, что касается верстки.



Во-первых, сама задача - сверстать все страницы сайта.
Disclaimer: очень рекомендую использовать bootstrap, о нем - в конце.
Материалы - пожалуй, все материалы по html и css есть здесь http://htmlbook.ru/ , плюс из скринкаста понятны общие положения. Для тех, кто захочет использовать bootstrap - http://getbootstrap.com/ , http://bootstrap-3.ru/index.php
Если какая-то нужная вам тема не освещена - вопросы приветствуются.

Теперь конкретика.
В целом задача довольно очевидная и лайтовая - проект должен выглядеть нормально :)
Технически я буду оценивать работу так:
1) объем работы
2) семантика и логичность верстки и стилей
3) правильность подключения css, js файлов
4) понимание вами того, как это работает

По пунктам

Объем работы
Я понимаю, что у каждого из вас своё видение проекта и того, как он должен выглядеть. Тем не менее, добавить в один шаблон один div и сказать "я так вижу" - не прокатит :)
Обычно верстка состоит из нескольких частей - шапка сайта (header сверху), подвал (footer снизу), блок для основного содержания, часто сбоку некоторый хелпер для навигации. На главной странице судя по всему некий dashboard (примерно как у меня в примере - 5 последних постов, 5 последних комментов или вроде того). Предлагаю сделать его в две колонки, но не обязательно. Просто посмотрите например на https://habrahabr.ru/ или на http://stackoverflow.com/ - станет понятно.
Конечно я не требую равнозначного хабру или stackoverflow объема работы, конечно вы можете сказать "на моем проекте бокового меню не будет, оно туда не вписывается". Я пойму, но в целом наглеть не стоит ;)

Семантика и логичность верстки и стилей
Я смотрю внутрь, и там должно быть аккуратно и стройно.
Если у вас где-то есть "лишний" по моему мнению элемент - спрошу :) Обратите внимание, не снижу оценку автоматиески, просто спрошу :)
Если вы используете (грубо говоря) span style="display: block;", хотя это же решается вставкой div-а - тоже спрошу :)

Правильность подключения css, js файлов
Стили выносим в отдельный файл (например, base.css в недрах core/static/).
Скрипты выносим в отдельный файл (например, base.js в недрах core/static/).
И то и другое подключается в head шаблона проекта.
У многих при подключении javascript-мимимишек возникнет вопрос "а как же мне передать в яваскрипт какие-то параметры из шаблона html". Этот вопрос я подробно опишу в посте про javscript, не переживайте, там всё достаточно просто.
Отдельно про правильное подключение статических файлов в Django - никаких "/static/.../base.css" - подключаем через тег static

{% load static %} (в начале шаблона)
{% static "core/base.css" %}

Не забывайте, что после этого нужно сделать manage.py collectstatic, чтобы файлы скопировались в ту папку, откуда их подхватывает nginx.
Да я же задолбаюсь каждый раз делать collectstatic после каждого изменения! (с)
https://docs.djangoproject.com/es/1.9/howto/static-files/#serving-static-files-during-development смотрите тут. Вкратце - можно заставить Django самостоятельно отдавать статику из той папки, которая настроена в settings.py в STATIC_ROOT. Рецепт по ссылке, если применен - нужно заходить браузером на порт 8080 (именно там у вас по идее крутится gunicorn). Тогда файлы вам отдаст не nginx, а gunicorn. Конечно, в конце все равно делаем collectstatic и проверяем, работает ли это всё в связке с nginx.
Вставка в css ссылок на картинки
Спасибо Саше Агафонову за то, что напомнил про это.
Вкратце - {% static %} внутри статических файлов не работает, так что просто используются _только_ относительные урлы.
Допустим, хотим добавить фон для элемента в виде картинки. Тогда нам в css нужно будет получить ссылку на картинку, лежащую у нас где-то в недрах static. В этом случае не нужно использовать абсолютный урл вида /static/полный-путь-к-картинке. Ссылка на картинку должна даваться относительно того css-файла, где она упоминается. На примере:

(css лежит в static/css/base.css, картинка - в static/img/bg.png)
.content {background-image: url(../img/bg.png)};

В этом случае всё будет работать так, как нужно. Проверить, верен ли путь, весьма просто - можно из папки с css-файликом просто сделать ls ../img/bg.png :) Ну или консоль браузера (вкладка network) покажет, откуда именно браузер пытается грузить картинку

Понимание вами того, как это работает
"Почему вот этот блок справа?"
"Откуда здесь берется стиль для текста поста?"
Ну и что-то подобное я могу поспрашивать, если мне покажется, что ДЗ было воспринято ну уж слишком легковесно :)
Ну это так, в целом.

Bootstrap
Многие, возможно, решат, что bootstrap сэкономит им какое-то количество времени и сил.
И окажутся в целом правы. Подключение bootstrap к странице довольно простое (всё есть тут http://getbootstrap.com/getting-started/ и примеры в том числе). На http://bootstrap-3.ru/getting-started.php тоже вполне годная статейка. Имейте ввиду - есть два способа подключить bootstrap к проекту - через CDN, либо скачав к себе в проект. Можно делать и так и так, но я опасаюсь, что в аудитории CDN может не загрузиться - спасибо нашему чудесному интернету в 430 аудитории :)
По применению bootstrap - http://bootstrap-3.ru/css.php , http://bootstrap-3.ru/components.php , http://bootstrap-3.ru/javascript.php - там ГОРА примеров и решений на все случаи жизни. И да, всплывающее модальное окно можно делать с помощью bootstrap, как и всё прочее :)

А как же мне добавить классы (стили, атрибуты) к элементу ввода формы, если вы запретили писать их чистым html?
Если коротко - вам сюда https://pypi.python.org/pypi/django-widget-tweaks
Это дополнительная библиотека к django, которая позволяет вертеть выводом формы как угодно. Например, рассмотрим случай с datepicker-виджетом из соседнего поста про JS. Наша задача - вывести поле ввода для даты и времени, добавив туда атрибут data-widget="datepicker". Стандартное поведение django.forms в шаблоне этого не позволяет. widget_tweaks же позволяет сделать это следующим образом (предположим, имя поля - post_date):

{% load widget_tweaks %}
...
{{ form.post_date|attr:"data-widget:datetime" }}

Я думаю, пример должен быть понятен. По ссылке выше еще примеры. Читайте внимательно секцию Installation из доки, и не забывайте, что установленный с помощью pip install компонент нужно добавить в requirements.txt (как именно - я писал в туториалу к первому ДЗ).
Если что-то не ясно, пишите в комментариях, дополню пост в этом случае.


ДЗ#4: JS
Основы веб-разработки (первый семестр)
Здесь о том, что касается javascript в рамках ДЗ#4.



Итак. Задача - есть три фичи (с)
формочка в диалоговом окне (делали на лекции)
автообновление списка объектов (делали на лекции)
кнопка лайка одного из объектов в списке, работающая через ajax
Берем любые две и реализовываем в проекте.
Если вам ни одна из этих не нравится, и вы хотите сделать что-либо другое - пожалуйста, я совершенно не против. Больше разнообразия - это безусловно хорошо! :)

Как я буду оценивать эту задачу:
Я буду оценивать её без жести, по двум критериям - корректность javascript-кода и собственно работоспособность самой фичи :)

jQuery, jQueryUI
Стандартная библиотека javascript довольно скудна, и делать на голом js что-либо комплексное - ад, боль и унижение. Поэтому есть немаленькое количество js-фреймворков, которые здорово облегчают жизнь. Стандарт де-факто сейчас пожалуй jquery и jqueryui.

jQuery
Это библиотека, реализующая огромное количество всевозможного функционала. Безусловно, в живой разработке вы столкнетесь именно с jquery в качестве основного инструмента для оживления проекта.
Домашний сайт библиотеки - https://jquery.com/
Кроме того, по интернету раскидана гора справочников, статей и туториалов. http://jquery.page2page.ru/ очень рекомендую. Так же, как и с bootstrap-ом - подключить можно как с cdn-а, так и просто скачав себе библиотеку.
Для jQuery существует огромное количество плагинов, реализующих тот или иной функционал на базе этой библиотеки. Например, очень рекомендую https://harvesthq.github.io/chosen/
Примеров - огромное количество, как и в документации так и просто раскидано по интернету.

jQueryUI
Надстройка над jQuery, включающая некоторое количество дополнительных виджетов.
Основной сайт - https://jqueryui.com/ , там же инструкция по установке. Кроме того, на http://jquery.page2page.ru/ тема jqueryui тоже подробно освещена.
Примеры виджетов - диалоговое окно, datepicker (календарик для выбора дат), autocomplete (замена стандартному select-у, спасающая в случае большого количества вариантов для выбора).

Вопросы вы задаете обычно в последний момент, так что попробую новый формат - придумаю вопросы за вас, и отвечу на них :)

А что, всплывающую формочку делать прям так, как в скринкасте?
Да не, та жесть была в обучающих целях. Есть куча плагинов, как в bootstrap так и в jqueryui. Берите то, что вам ближе.

Вы заставляете меня выносить весь js в отдельный файл, а как же мне сделать что-то с конкретным элементом, или передать в скрипт какой-либо параметр из шаблона???
Для этого используйте data-атрибуты, сейчас покажу как.
У любого html-элемента есть возможность определить некоторое количество атрибутов, начинающихся с data-. Это специальное подмножество атрибутов, выделенное специально для того, чтобы их содержимое читалось js-скриптами. То есть, с помощью этих атрибутов можно сконфигурировать поведение того или иного элемента.

На примере:
Допустим, у нас на странице есть поле ввода для даты. По умолчанию оно не очень удобно, и мы хотим сделать из него няшный календарик средствами jqueryui (вот он https://jqueryui.com/datepicker/).
Допустим, наш собственный js-скрипт для проекта (он у нас пока один) лежит в base.js.
Что мы делаем - прежде всего нам нужно заставить яваскрипт найти этот элемент на странице. Следите за руками -

(в шаблоне)
<input type="text" name="mydate" data-widget-type="datepicker">

(в js-файле)
$('[data-widget-type=datepicker]').datepicker();

Что мы только что сделали - нашли все элементы с атрибутом data-widget-type равным datepicker и вызвали для них метод datepicker (данный метод находится в составе jqueryui и расширяет возможности стандартного jquery).
Кроме того, можно проитерироваться по всем найденным элементам и для каждого из них сделать что-либо, это делается так:

$('[data-widget=datepicker]').each(function() {
    console.log(this)
});

Здесь мы у найденного множества элементов вызываем метод each, он делает следующее - берет функцию, переданную ему в качестве параметра, и вызывает её для каждого отдельного элемента. Причем внутри этой функции сам очередной элемент доступен нам в переменной this.
Кстати, обратите внимание на вызов console.log - это способ посмотреть что-либо прямо в консоли браузера (в нашем случае переменная this появится во вкладке console, а про консоль браузера есть в скринкасте).
Итак, перепишем немношк более комплексно:

$('[data-widget=datepicker]').each(function() {
    $(this).datepicker();
});

Так мы пробежались по всем элементам с атрибутом data-widget=datepicker и для каждого вызвали метод datepicker. Конструкция $(this) - это получение обертки jquery над самим html-элементом.

Еще пример:
Допустим, мы прикручиваем то самое автообновление комментариев. То есть - у нас есть div, в который нужно время от времени загружать что-либо. В моем примере вызов скрипта происходит прямо в коде html-страницы. Вам же нужно вынести его в ваш js-файл. У вас возникнет проблема - ссылку, с которой качаются комментарии, вы можете получить только в django-шаблоне. А статические файлы через django-шаблонизатор не проходят, они передаются браузеру "как есть". А значит ни о каком теге {% url %} там не может быть и речи. Решение получается примерно вот такое:

(в шаблоне)
<div data-update-from="{% url... %}"></div>

(в js-файле)
$('[data-update-from]').each(function() {
    var url = $(this).data('update-from');
    ура, теперь мы в переменной url знаем нужную ссылку, можем включать код из примера!
});

Что мы сделали - выбрали все элементы, где вообще присутствует атрибут data-update-from. Пробежались по ним всем - и для каждого получили значение атрибута с помощью встроенного метода .data(имя-атрибута). Таким образом мы вытащили для каждого элемента нужный параметр, который мы ставили ему еще на этапе html-шаблона django. И можем делать то, что нам надо.

Так вы же запретили писать элементы ввода форм чистым html, только через forms. Как же мне добавить атрибут к полю?
Об этом читайте в соседнем посте про верстку.

Я хочу прикрутить лайки, а как же мне сделать что-то по клику на элемент?
Допустим, у нас есть div, в котором валяется текущее количество лайков, и мы хотим при клике на него передавать на сервер новый лайк. Как совершить саму передачу, понятно из предыдущего пункта - мы просто грузим новый html в этот div, а сервер при выдаче этого html добавляет в нужную модельку еще один лайк. Как же нам сделать так, чтобы при клике на этот div начинала работать какая-либо функция?
На примере

(в шаблоне)

<div data-click-action="{% url ... %}">{{ post.likes_count }}</div>

(в js)
$(document).on('click', '[data-click-action]', function() {
    console.log(this);
    проверяем, что работает
    return false;
});

Что мы сделали -
Во-первых, в data-click-action положили тот самый урл, который добавит единичку, сохранит объект в базу и вернет нам новое количество лайков для объекта (реализация его - на вашей совести :)
Во-вторых, есть метод on - принимает три параметра -
название события (или event) - в нашем случае click
селектор элементов - для каких элементов метод должен сработать, а для каких - нет; в нашем случае - для всех элементов с атрибутом data-click-action
callback - функция, которая будет вызвана для отдельного элемента в случае возникновения события. внутри - сам элемент в переменной this.
Сам метод on вызывается для того элемента, внутри которого мы вообще хотим переопределить событие.
В нашем случае мы объявляем, что хотим слушать события типа click внутри элемента document (это вся страница в целом). И если событие произошло у элемента, который попадает под фильтр "[data-click-action]" - вызывать данную функцию. Внутри функции мы делаем просто console.log(this) - чтобы проверить, работает ли оно. То есть, пока просто печатаем элемент, на который кликнули.
Кто напишет в каментах, зачем return false в конце и где он нам может понадобиться - тому плюс балл :)
Короче говоря, вот так мы на определенные элементы вешаем собственную реакцию на клик пользователем. Внутри функции-callback-а мы можем делать все, что хотим, в том числе загружать для этого элемента новое содержимое. Как именно это делается - было на лекции, а значит есть в скринкасте ;)

А мне прям вот брать base.js и писать туда все, что я хочу сделать?
Не совсем. Все действия с javascript нужно производить только после изначальной загрузки документа. В jquery для этого есть хелпер - функция вот такого вида:

$(function () {

    console.log('lalala');
    $('[data-widget-type=datepicker]').datepicker();
    все остальное...

});

В этом примере мы заворачиваем всё, что хотим сделать, в еще одну функцию. И такой вызов гарантирует нам, что наши действия будут выполнены только после того, как браузер отрисует все элементы на странице. Это важно.